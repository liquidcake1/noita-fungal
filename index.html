<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<script language="javascript" type="module">
			import { run_queue_step, init } from "./main.mjs";
			function load() {
				document.getElementById("seed").addEventListener("change", seed_changed);
				document.getElementById("grow").addEventListener("click", add_cup);
				document.getElementById("imagine").addEventListener("click", imagine);
				document.getElementById("flint").addEventListener("click", apply_flint);
				document.getElementById("recipe_nr").addEventListener("change", recipe_changed);
				seed_changed();
				add_cup();
			}
			var transmutations = [];
			var transmutation_rows = [];
			function add_cup() {
				let altar = document.getElementById("altar");
				let transmutation = document.createElement("tr");
				let transmutation_count = transmutations.length;
				transmutations.push({});
				transmutation.appendChild(create_cup("sacrifice", transmutation_count));
				transmutation.appendChild(create_cup("product", transmutation_count));
				transmutation.appendChild(create_cup("stain", transmutation_count));
				transmutation.appendChild(create_cast(transmutation_count));
				transmutation_rows[transmutation_count] = transmutation;
				altar.appendChild(transmutation);
			}
			function create_cup(purpose, index) {
				let saucer = document.createElement("td");
				let cup = document.createElement("select");
				transmutations[index][purpose] = cup;
				dream(cup);
				saucer.appendChild(cup);
				return saucer;
			}
			function create_cast(index) {
				let pedestal = document.createElement("td");
				let cast = document.createElement("input");
				cast.value = "Cast into the void";
				cast.type = "button";
				cast.addEventListener("click", function () {
					cast_into_void(index);
				});
				pedestal.appendChild(cast);
				return pedestal;
			}
			function cast_into_void(index) {
				let transmutation = transmutations.splice(index, 1)[0];
				let altar = document.getElementById("altar");
				altar.removeChild(transmutation_rows.splice(index, 1)[0]);
			}
			function dream(cup) {
				let i = 0;
				for (let material of Array.from(materials).sort()) {
					cup.appendChild(thought(material));
					if (material == "air") {
						cup.selectedIndex = i;
					}
					i++;
				}
			}
			function thought(material, selected) {
				let new_thought = document.createElement("option");
				new_thought.name = material;
				new_thought.text = material;
				return new_thought;
			}
			function imagine() {
				let mind = document.getElementById("mind").value;
			}
			function imagine_real(mind) {
				if (mind == "") {
					return;
				} else if (materials.has(mind)) {
					return;
				} else {
					materials.add(mind);
					for(let transmutation of transmutations) {
						for(let cup of Object.values(transmutation)) {
							cup.appendChild(thought(mind));
						}
					}
				}
			}
			var materials = new Set();
			var state = null;
			function seed_changed() {
				seed = document.getElementById("seed").valueAsNumber;
				state = init(seed);
				imagine_real("air");
				for(let ng_shifts of state.world_state.all_shifts) {
					for(let shift of ng_shifts) {
						for(let material of shift.base) {
							imagine_real(material);
						}
						imagine_real(shift.target);
					}
				}
			}
			function pray_to_gods(constraints) {
				let requirements = [];
				let end_state = {};
				for(let transmutation of transmutations) {
					let sacrifice = transmutation["sacrifice"].value;
					let product = transmutation["product"].value;
					let stain = transmutation["stain"].value;
					if (sacrifice == "air") {
						if (product != "air") {
							return "A product requires a sacrifice.";
						}
						if (stain != "air") {
							return "A stain requires sacrifice.";
						}
					} else {
						if (product == "air") {
							return "The gods cannot countenance annihilation.";
						}
						let constraint = {
							"base": sacrifice,
							"target": product,
						};
						if (end_state[sacrifice] && end_state[sacrifice] != product) {
							return `The anfractuous cycle so-created contradicts the bounds of reality. ${sacrifice} must become both ${end_state[sacrifice]} and ${product}.`;
						}
						end_state[sacrifice] = product;
						if (stain != "air") {
							constraint.stain = stain;
							if (end_state[product] && end_state[product] != stain) {
								return `The anfractuous cycle so-created contradicts the bounds of reality. ${product} must become both ${end_state[product]} and ${sacrifice}.`;
							}
							end_state[product] = stain;
						}
						constraints.push(constraint);
					}
				}
				if (constraints.length == 0) {
					return "the gods find only emptiness";
				}
			}
			function clear_tablet() {
				document.getElementById("tablet").innerText = "";
			}
			function decree(announcement) {
				clear_tablet();
				let engraving = document.createElement("p");
				engraving.appendChild(document.createTextNode(announcement));
				document.getElementById("tablet").appendChild(engraving);
			}
			var timeout = null;
			function apply_flint() {
				let constraints = [];
				let response = pray_to_gods(constraints);
				if (response) {
					decree(response);
					return;
				}
				seed_changed();
				state.world_state.constraints = constraints;
				state.running = true;
				document.getElementById("flint").removeEventListener("click", apply_flint);
				document.getElementById("flint").addEventListener("click", douse);
				document.getElementById("flint").value = "Douse the apparatus";
				document.getElementById("recipe_nr").valueAsNumber = null;
				console.log("The fires are lit.");
				run_step();
			}
			function douse() {
				if (timeout) {
					window.cancelTimeout(timeout);
					timeout = null;
				}
				if (state) {
					state.running = false;
				}
				document.getElementById("flint").removeEventListener("click", douse);
				document.getElementById("flint").addEventListener("click", apply_flint);
				document.getElementById("flint").value = "Start the fires of the calculation engine";
				console.log("The fires are extinguished.");
			}
			function run_step() {
				if (!state || !state.running) {
					return;
				}
				let game_name = "New Game";
				for(let i=0; i<state.base_ng; i++) {
					game_name += "+";
				}
				for(let i=0; i<100000; i++) {
					run_queue_step(state);
				}
				let message = "";
				if (!state.finished) {
					message += `Studying the properties of ${game_name}`;
					if (state.shift_nr < 20) {
						message += `; moving to ${game_name}+ after ${state.shift_nr} shifts. `;
					} else {
						message += ". ";
					}
				} else {
					douse();
				}
				message += `${state.total_jobs} realities have been tested. ${state.solutions.length} recipes have been uncovered. `;
				let recipe_nr_elt = document.getElementById("recipe_nr");
				if (state.solutions.length > 0) {
					let best_solution = state.solutions[state.solutions.length - 1];
					message += ` The shortest recipe requires NG+${best_solution.base_ng} and has ${best_solution.length} shifts.`;
					recipe_nr_elt.min = 1;
					recipe_nr_elt.max = state.solutions.length;
					if (!recipe_nr_elt.valueAsNumber) {
						recipe_nr_elt.valueAsNumber = 1;
						recipe_changed();
					}
					document.getElementById("recipes").style = "";
				} else {
					document.getElementById("recipes").style = "display: none;"
					recipe_nr_elt.valueAsNumber = null;
				}
				decree(message);
				window.setTimeout(run_step);
			}
			function recipe_changed() {
				console.log("Recipe changed");
				let recipe_nr = document.getElementById("recipe_nr").valueAsNumber;
				let world, held_materials, shift_nr, shifts;
				if (recipe_nr) {
					let recipe = state.solutions[recipe_nr-1];

					let pre_state_elt = document.getElementById("pre_state");
					if (recipe.base_ng) {
						let game_name = "New Game";
						for(let i=0; i<state.base_ng; i++) {
							game_name += "+";
						}
						pre_state_elt.innerText = `First, proceed to ${game_name}. `;
					} else {
						pre_state_elt.innerText = "This recipe is to be started in New Game. ";
					}
					pre_state_elt.innerText += `This recipe needs ${recipe.held_materials.length} shifts.`;
					held_materials = recipe.held_materials;
					world = recipe.state;
					shift_nr = recipe.shift_nr;
					length = recipe.length;
					shifts = recipe.shifts;
				} else {
					world = {};
					held_materials = [];
					shift_nr = 20;
					length = 0;
					shifts = [];
				}
				let world_keys = Array.from(Object.keys(world)).sort();
				let world_elt = document.getElementById("world");
				while(world_elt.childNodes.length > 2) {
					world_elt.removeChild(world_elt.childNodes[2]);
				}
				for(let i=0; i<world_keys.length; i++) {
					let tr = document.createElement("tr");
					tr.appendChild(td_text(world_keys[i]));
					tr.appendChild(td_text(world[world_keys[i]]));
					if (world[world[world_keys[i]]]) {
						tr.appendChild(td_text(world[world[world_keys[i]]]));
					}
					world_elt.appendChild(tr);
				}
				let recipe_elt = document.getElementById("recipe");
				while(recipe_elt.childNodes.length > 2) {
					recipe_elt.removeChild(recipe_elt.childNodes[2]);
				}
				world = {};
				for(let i=0; i<length; i++) {
					if (i == shift_nr) {
						let skip = document.createElement("tr");
						let skip_in = td_text("GO TO NEXT NEW GAME");
						skip_in.colSpan = 4;
						recipe_elt.appendChild(skip_in);
					}
					let tr = document.createElement("tr");
					let material = held_materials[i];
					if (!material) {
						// null means unused; undefined means forced
						material = "air";
					}
					tr.appendChild(td_text(material));
					let sacrifices = shifts[i].base;
					let product = shifts[i].product;
					if (material == "air") {
						tr.appendChild(td_text(""));
					} else if (shifts[i].held == "from") {
						tr.appendChild(td_text("Sacrifice"));
						sacrifices = [material];
					} else if (shifts[i].held == "to") {
						tr.appendChild(td_text("Product"));
						product = material;
					}
					if (world[product]) {
						product = world[product];
					}
					let sacrifices_elt = document.createElement("td");
					for(let sacrifice of sacrifices) {
						let p = document.createElement("p");
						p.appendChild(document.createTextNode(sacrifice));
						sacrifices_elt.appendChild(p);
						world[sacrifice] = product;
					}
					tr.appendChild(sacrifices_elt);
					tr.appendChild(td_text(product));
					recipe_elt.appendChild(tr);
				}
			}
			function td_text(text) {
				let td = document.createElement("td");
				td.appendChild(document.createTextNode(text));
				return td;
			}
			load();
		</script>
		<style>
table { border: black solid 1px; padding: 0px; }
th { font-family: monospace; font-weight: normal; }
td { font-family: monospace; background: lightgrey; width: 1em; padding: 0px; text-align: center; }
td > p { margin-bottom: 0px; margin-top: 0px; }
		</style>
		<title>Noita Fungal Solver</title>
	</head>
	<body>
		<h1>Noita Fungal Solver</h1>

		<div>
			<p>For the purposes of great alchemies, the Solver may take from a curious witch five things.</p>
			<p>First, the master must seek and supply the Seed from which the world was grown. This will embed within the machine the means to see into the unknown.</p>
			<p>Second, all alchemy demands Sacrifices to begin any transmutation. They must be hung within the first column. Beware when making use of those rare things, as sufficient quantities will need to be found to cause changes upon the world.</p>
			<p>Third, the Productions of the alchemies must be made known. Place them centrally upon the altar. As with the sacrifices, rare reagents must be sought to complete the ritual. Elements which are offensive to the world will burden the caster with most unfortunate circumstances as the results will likely involve their multiplication.</p>
			<p>Fourth, in the process of the art of permutations, damage may be done to the properties of things, in particular their Stains. Place at the rightmost locations the material of the Stains. A brave practitioner may leave empty these cups and allow what will be to be, but beware the happenings that may result.</p>
			<p>Finally, great time must be devoted. The machine may take many seconds to test the many realities.</p>
		</div>

		<p>Place here, the seed of your world: <input id="seed" type="number" value="0"/></p>

		<table id="altar">
			<tr>
				<th><span title="The 'from' material in your desired fungal shift.">Sacrifice</span></th>
				<th><span title="The eventual appearance of your 'from' material.">Product</span></th>
				<th><span title="The 'broken shift', which affects the effects of staining, among other things. Can be left blank.">Stain</span></th>
			</tr>
		</table>

		<p>If the altar must have more cups, they may be <input type="button" id="grow" value="placed"/> upon it.</p>
		<p>With the fires of imagination, the material of <input id="mind" type="text"/><input type="button" id="imagine" value="is created"/> to be placed within the cups.</p>

		<div id="tablet"></div>

		<div id="recipes" style="display: none;">
			<input id="recipe_nr" type="number"/>
			<p id="pre_state"/>
			<h2>The Recipe</h2>
			<table id="recipe">
				<tr>
					<th>Presentation</th>
					<th>Interpretation</th>
					<th>Sacrifices</th>
					<th>Products</th>
				</tr>
			</table>
			<h2>The New World</h2>
			<table id="world">
				<tr>
					<th>Initiate</th>
					<th>Appearance</th>
					<th>Stain</th>
				</tr>
			</table>
		</div>

		<input type="button" id="flint" value="Start the fires of the calculation engine"/>

		<h2>Boring stuff</h2>

		<p>The code to fetch shifts for a seed is from <a href="https://github.com/TwoAbove/noita-tools">noita-tools</a> (Noitool). This code is available under the <i><a href="https://github.com/TwoAbove/noita-tools/blob/30bcc629c681291657cb1938c296c0cbc4b2043e/LICENSE">MIT license</a></i>. Copyright (c) 2022 Seva Maltsev <me@seva.dev> (<a href="https://seva.dev/">https://seva.dev/</a>)"</p>
		<p>Remainder of copyright and related rights waived via <i><a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a></i>.</p>
	</body>
</html>
